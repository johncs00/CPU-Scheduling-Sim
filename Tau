import sys
import time
import random as rand
import math
import queue
import heapq


class rand:
    def __init__(self, seed):
        self.n = seed

    def setSeed(self, seed):
        self.n = seed

    def lcg(self):
        self.n = (25214903917 * self.n + 11) & (2 ** 48 - 1)
        return self.n

    def srand48(self, seed):
        self.n = (seed << 16) + 0x330e

    def drand48(self):
        return self.lcg() / 2 ** 48


class Process:
    def __init__(self, name, cpu_times, io_times, cpu_index, io_index, state, num_burst, arrival_time, turn_time,
                 wait_time, input_tau, tau_array):
        self.n = name
        self.cpu = cpu_times
        self.io = io_times
        self.cpu_i = cpu_index
        self.io_i = io_index
        self.s = state
        self.b = num_burst
        self.a = arrival_time
        self.turn = turn_time
        self.wait = wait_time
        self.tau = input_tau
        self.tauarray = tau_array

    def __lt__ (self, obj):
            """self < obj."""
            if(self.tauarray[self.cpu_i] == obj.tauarray[obj.cpu_i]):
                return self.n < obj.n
            else:
                return (self.tauarray[self.cpu_i] < obj.tauarray[obj.cpu_i])

def burstnumber(input):
    input = input * 100
    input = math.trunc(input)
    input += 1
    return input


def printNames(ready_queue):
    if (len(ready_queue) == 0):
        return "<empty>]"
    string = ""
    for p in ready_queue:
        if (ready_queue.index(p) == (len(ready_queue) - 1)):
            string += p.n + "]"
        else:
            string += p.n + " "
    return string


def randList(l, upperbound, seed):
    min = 0
    max = 0
    sum = 0
    iterations = 100000
    # l = 0.001
    r_list = []
    randy = rand(seed)
    randy.srand48(seed)
    for i in range(iterations):
        # replace random() with drand48
        r = randy.drand48()  # / * uniform # dist[0.00, 1.00) -- also check out random() * /

        x = -math.log(r) / l  # / lambda; / * log() is natural log * /
        # / * avoid values that are far down the "long tail" of the distribution * /

        if (x > upperbound):
            i -= 1
            continue
            # print("x is ", x)

        pair = (x, r)


        r_list.append(pair)
        sum += x
        if (i == 0 or x < min):
            min = x
        if (i == 0 or x > max):
            max = x

        avg = sum / iterations

    return r_list
    # print( "minimum value: ", min)
    # print( "maximum value: ", max)
    # print( "average value: ", avg)


def SJF(plist_SJF, preempt, location, switchtime):
    switching = False
    halfswitch = False
    if switching:
        print("relax")
    time = 0
    target = 0
    readyQ = []
    readyQ.append(plist_SJF[0])
    heapq.heapify(readyQ)
    heapq.heappop(readyQ)
    print("arrived")
    waitingQ = []
    running = []
    run_counter = 0
    for p in plist_SJF:
        print("Process", p.n, "[NEW] (arrival time", p.a, "ms) ", p.b, "CPU bursts")
    while True:
        if time % 10000 == 0:
            print(time)
        if time == 100000:
            break
        # time string
        s = 'time ' + repr(time) + ':ms'
        if (time == 0 and not(preempt)):
            print(s, "Simulator started for SJF [Q", printNames(readyQ))
        elif(time == 0 and preempt):
            print(s, "Simulator started for SRTF [Q", printNames(readyQ))
        # context switch
        if (not switching):
            # decrement the running process, does nothing if there is no running process
            for p in running:
                p.cpu[p.cpu_i] -= 1
                run_counter += 1
            # check if the running process finished
            for p in running:
                if (p.cpu[p.cpu_i] == 0):
                    switching = True
                    p.cpu_i += 1
                    if (time < 2000):
                        print(s, "Process", p.n, "completed a CPU burst;", (p.b - p.cpu_i), "bursts to go [Q",
                              printNames(readyQ))
                        print(s, "Process", p.n, "switching out of CPU; will block on I/O until time " + str(
                            time + p.io[p.io_i]) + "ms [Q", printNames(readyQ))
                    if (p.cpu_i == (p.b - 1)):  # if(c_counter[plist_RR.index(p)] == p.b):
                        if (time < 1000):
                            print("Process", p.n, "terminated [Q", printNames(readyQ))
                        run_counter = 0
                        plist_SJF.remove(p)
                        running.remove(p)
                    else:
                        running.remove(p)
                        waitingQ.append(p)
            # check if nothing is running
            for p in readyQ:
                if (len(running) == 0):
                    halfswitch = True
                    #do SJF algo
                    running.append(p)
                    readyQ.remove(p)
                    run_counter = 0
                    if (time < 2000):
                        print(s, "Process", p.n, "started using the CPU for " + str(p.cpu[p.cpu_i]) + "ms burst [Q",
                              printNames(readyQ))
            # end of if !switching statement
        # check if any I/O has finished, and if so add to the readyQ. If not, decrement all
        for p in waitingQ:
            if (p.io[p.io_i] == 0):  # if(p.io[0 + i_counter[plist_RR.index(p)]] == 0):
                waitingQ.remove(p)
                p.io_i += 1  # i_counter[plist_RR.index(p)] += 1
                readyQ.append(p)
                if (time < 1000):
                    print(s, "Process", p.n, "completed I/O; added to the ready queue [Q", printNames(readyQ))
            else:
                p.io[p.io_i] -= 1  # p.io[0 + i_counter[plist_RR.index(p)]] -= 1

        # check if any processes arrive
        for p in plist_SJF:
            if (p.a == time):
                # print("CPU times", p.cpu)
                # print("I/O times", p.io)
                readyQ.append(p)
                if (time < 1000):
                    print(s, "Process", p.n, "arrived; added to the ready queue [Q", printNames(readyQ))

        if (switching):
            if (halfswitch):
                target = time + (switchtime / 2)
            else:
                target = time + switchtime
            if (time == target):
                switching = False
                halfswitch = False

        time += 1

        if (len(plist_SJF) == 0):
            break
    print(s, "Simulation ended")
    # end of SJF

if __name__ == "__main__":
    inputlen = len(sys.argv)
    if (not (inputlen == 9 or inputlen == 8)):
        # make the code fucking stop here
        print("bad args")

    numpros = int(sys.argv[1])
    seed = int(sys.argv[2])
    l = float(sys.argv[3])
    expceil = int(sys.argv[4])
    switchtime = int(sys.argv[5])
    alpha = float(sys.argv[6])
    tslice = int(sys.argv[7])
    rradd = "END"  # end
    # check if the optional one is added
    if (inputlen == 9):
        print(sys.argv[8])
        if (sys.argv[8] == "END"):
            rradd = "END"
        elif (sys.argv[8] == "BEGINNING"):
            rradd = "Beginning"
        else:
            print("invalid arg 8")
            print("Testing")

            # bursttest = 0.0856756876765
    # bursttest = burstnumber(bursttest)
    # print(bursttest, "This should be 9")

    # replace l with argv[3]
    # replace upperbound with argv[4]

    process_names = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
                     'U', 'V', 'W', 'X', 'Y', 'Z']
    plist_RR = []
    plist_SRT = []
    plist_SJF = []
    plist_FCFS = []

    # fill each list with default processes
    for i in range(numpros):
        plist_SJF.append(Process(process_names[i], [], [], 1, 0, 0, 0, 0, 0, 0, math.ceil(1/l), []))
        plist_SRT.append(Process(process_names[i], [], [], 1, 0, 0, 0, 0, 0, 0, math.ceil(1/l), []))

    # DO calculations to give proceses their rime values.
    interarrival = randList(l, expceil, seed)
    rand_index = 0
    for p in plist_SRT:
        p.a = (math.floor(interarrival[rand_index][0]))
        rand_index += 1
        temp_num_burst = burstnumber(interarrival[rand_index][1])
        p.b = (temp_num_burst)
        rand_index += 1
        for r in range(temp_num_burst):
            p.cpu.append(math.ceil(interarrival[rand_index][0]))
            rand_index += 1
            if (r == temp_num_burst - 1):
                break
            p.io.append(math.ceil(interarrival[rand_index][0]))
            rand_index += 1

    rand_index = 0
    for p in plist_SJF:
        p.a = (math.floor(interarrival[rand_index][0]))
        rand_index += 1
        temp_num_burst = burstnumber(interarrival[rand_index][1])
        p.b = (temp_num_burst)
        rand_index += 1
        for r in range(temp_num_burst):
            p.cpu.append(math.ceil(interarrival[rand_index][0]))
            rand_index += 1
            if (r == temp_num_burst - 1):
                break
            p.io.append(math.ceil(interarrival[rand_index][0]))
            rand_index += 1
    for k in range(len(plist_SJF)):
        for i in range(plist_SJF[k].b):
            if i == 0:
                plist_SJF[k].tauarray.append(plist_SJF[k].tau)
            else:
                plist_SJF[k].tauarray.append(math.ceil(alpha * plist_SJF[k].cpu[i-1] + (1-alpha) * plist_SJF[k].tauarray[i-1]))
    for k in range(len(plist_SJF)):
        print(plist_SJF[k].tauarray)
    SJF(plist_SJF, False, rradd, switchtime)
